# Google Java Style Guide - Korean

> 이 문서는 [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)의 한국어 번역본입니다. 해당 스타일 가이드는 우아한테크코스 6기 웹 백엔드 과정에서 준수해야하는 코드 컨벤션이기도 합니다. 원본과 다른 우아한테크코스만의 컨벤션은 따로 표기해두었습니다.

## 1. 서론

이 문서는 Java™ 프로그래밍 언어의 소스 코드를 위한 Google의 코딩 기준을 **완전하게** 정의합니다. Java 소스 파일은 이 문서의 규칙들을 준수한 경우에만 *Google Style*이라 할 수 있습니다.

다른 프로그래밍 스타일 가이드와 마찬가지로, 코드 형식의 미적 문제 뿐만 아니라 다른 종류의 컨벤션이나 코딩 기준도 다룹니다. 그러나, 이 문서는 우리가 보편적으로 따르는 **매우 엄격한 규칙**에 초점을 두고 있으며, (사람이든 도구든) 명확하게 시행할 수 없는 _조언_ 은 주지 않으려고 합니다.

### 1.1 용어 정리

이 문서에서는 달리 설명하지 않는 한,

1. _클래스_ 는 "일반" 클래스, 열거 클래스, 인터페이스나 `@interface` 어노테이션을 의미합니다.
2. _멤버_ (클래스의)는 중첩 클래스, 필드, 메소드, 생성자와 같이 초기화 구문이나 주석을 제외한 모든 최상위 요소들을 의미합니다.
3. _주석_ 은 항상 _구현_ 주석을 의미합니다. 우리는 "문서 주석"이라는 용어를 사용하지 않으며, 대신 "Javadoc"이라는 보편적인 용어를 사용합니다.

다른 "용어 정의"가 문서 전반에 걸쳐 종종 등장합니다.

### 1.2 가이드 메모

이 문서의 예제 코드는 **비표준**입니다. 예제들이 Google Style이라고 해서, _유일한_ 스타일리시한 코드 표현법을 설명하는 것은 아닙니다. 예제에서 선택된 임의의 코드 형식이 규칙으로 적용되어서는 안됩니다.

## 2. 소스 파일 기본 사항

### 2.1 파일 이름

소스 파일 이름은 최상위 클래스(단 하나만 존재하는)의 대소문자를 구분하는 이름과 `.java` 확장자로 구성됩니다.

### 2.2 파일 인코딩: UTF-8

소스 파일은 **UTF-8**로 인코딩되어야 합니다.

### 2.3 특수 문자

#### 2.3.1 공백 문자

라인 종료자(줄바꿈 문자)를 제외하고, **ASCII 수평 공간 문자 (0x20)** 가 소스 파일 어디에서나 나타나는 유일한 공백 문자입니다. 이것이 의미하는 바는 다음과 같습니다:

1. 문자열과 문자 리터럴의 모든 다른 공백 문자들은 이스케이프 됩니다.
2. 탭 문자들은 들여쓰기에 **사용되지 않습니다.**

#### 2.3.2 특수 이스케이프 문자

특수 이스케이프 문자(`\b`, `\t`, `\n`, `\f`, `\r`, `\"`, `\'` 와 `\\`)를 포함하는 어떠한 문자든, 해당 문자는 상응하는 8진수(예: `\012`)나 유니코드(예: `\u000a`) 이스케이프 문자 대신 사용됩니다.

#### 2.3.3 ASCII가 아닌 문자

ASCII가 아닌 나머지 문자의 경우, 실제 유니코드 문자(예: `∞`)가 사용되거나 상응하는 유니코드 이스케이프 문자(예: `\u221e`)가 사용됩니다. 문자열 리터럴에서 유니코드는 이스케이프되며, 주석에서는 강력하게 권장되지 않지만, 이러한 선택은 **코드를 더 읽기 쉽고 이해하기 쉽게 하기 위해**서 만들어졌습니다.

> **팁:** 유니코드 이스케이프의 경우나, 종종 실제 유니코드 문자가 사용될 때에도, 설명 주석이 매우 도움이 될 수 있습니다.

| 예시                                                    | 설명                                                                     |
| ------------------------------------------------------- | ------------------------------------------------------------------------ |
| `String unitAbbrev = "μs";`                             | 최적: 주석을 사용하지 않고도 명확합니다.                                 |
| `String unitAbbrev = "\u03bcs"; // "μs"`                | 허용되지만 이렇게 작성할 이유가 없습니다.                                |
| `String unitAbbrev = "\u03bcs"; // 그리스 문자 mu, "s"` | 허용되지만 이상하고 실수하기 쉽습니다.                                   |
| `String unitAbbrev = "\u03bcs";`                        | 형편 없음: 읽는 사람이 이것이 무엇인지 알 수 없음                        |
| `return '\ufeff' + content; // byte order mark`         | 좋음: 출력할 수 없는 문자들에 이스케이프를 사용함. 필요하면 주석을 사용. |

> **팁:** 몇몇 프로그램이 ASCII가 아닌 문자를 제대로 처리하지 못할까 봐 코드를 덜 간단하게 읽을 수 있도록 작성하지 마세요. 만약 그런 일이 발생한다면, 해당 **프로그램이 고장난 것**이며, **고쳐져야 하는 것**입니다.

## 3. 소스 파일 구조

소스 파일은 **다음과 같은 순서로** 결정되어야 합니다.

1. 라이선스나 저작권 정보가 있다면.
2. 패키지 선언문.
3. `import`문들.
4. **정확히** 단 하나의 최상위 클래스

만약 각 항목이 존재한다면, **정확히 한 줄**로 각 항목들을 구분합니다.

### 3.1 라이선스와 저작권 정보

만약, 파일에 라이선스나 저작권 정보가 있다면, 이곳에 속합니다.

### 3.2 패키지 선언문

패키지 선언문은 **라인-래핑**(자동 줄바꿈)되지 않습니다. 열 제한([4.4 열 제한: 100](ttps://github.com/hangillee/TIL/blob/main/Java/Google%20Java%20Style%20Guide.md))은 패키지 선언문에 적용되지 않습니다.

### 3.3 `import`문들

#### 3.3.1 와일드카드 import 하지 않음

`static`이나 그 외의 **와일드카드 `import`** 는 사용되지 않습니다.

#### 3.3.2 라인-래핑 하지 않음

`import`문은 **라인-래핑**(자동 줄바꿈)되지 않습니다. 열 제한([4.4 열 제한: 100](https://github.com/hangillee/TIL/blob/main/Java/Google%20Java%20Style%20Guide.md))은 `import`문에 적용되지 않습니다.

#### 3.3.3 순서와 공백

`import`문들은 다음과 같은 순서로 정렬됩니다:

1. 모든 `static import`문들을 하나의 블록으로.
2. 나머지 `import`문들을 하나의 블록으로.

`static import`와 그 외의 `import`문들이 모두 있다면, 두 블록을 하나의 공백 줄로 구분한다. `import`문 사이에는 그 외의 공백은 없습니다.

각 블록은 ASCII 정렬 순서로 정렬됩니다. (**참고:** ';' 앞에 '.'가 정렬되므로 `import`문이 ASCII 정렬 순서로 있는 것과 같지 않습니다.)

#### 3.3.4 클래스는 `static import` 하지 않음

`static import`는 `static` 중첩 클래스에는 사용되지 않습니다. 해당 클래스들은 일반 `import`문을 사용합니다.

### 3.4 클래스 선언

#### 3.4.1 정확히 하나의 최상위 클래스

소스 파일에는 각자의 유일한 최상위 클래스가 존재합니다.

#### 3.4.2 클래스 요소 순서

클래스의 멤버들과 초기화 구문들의 순서는 학습 가능성에 큰 영향을 미칠 수 있습니다. 그렇다고 하나의 정답이 있는 것도 아닙니다. 다른 클래스들은 그들의 요소들을 다른 순서로 정렬할 것입니다.

중요한 것은 각 클래스가, **어떠한 논리적 순서**를 사용한다는 것입니다. 이 순서는 유지보수자에 의해 설명될 수 있어야 합니다. 예를 들어, 새 메소드들은 관습적으로 클래스의 끝에 추가되지 않는데, 이것은 "추가된 시간 순"으로 산출된 결과이지, 논리적 순서가 아닙니다.

##### 3.4.2.1 오버로드: 절대 나누지 마라

클래스의 메소드들이 같은 이름을 공유하고 있다면 중간에 다른 멤버 없이 연속된 단일 그룹에 있어야 합니다. 이는 여러개의 생성자(항상 같은 이름을 가지는)에도 적용됩니다. 이 규칙은 `static`이나 `private` 키워드에 의해 메소드들 사이의 차이가 생겨도 적용됩니다.

## 4. 포매팅

**용어 정의:** _block-like construct_(블록과 같은 구조)는 클래스, 메소드나 생성자의 `body`를 의미합니다. 4.8.3.1 [배열 초기화]() 항목의, 배열 초기화는 블록과 같은 구조로 취급될 수 있습니다.

### 4.1 중괄호

#### 4.1.1 중괄호는 선택적인 상황에서도 사용

`if`, `else`, `for`, `do`와 `while` 구문의 `body`가 비어있거나 단 한 줄의 구문만 가지고 있어도 중괄호를 사용해야 합니다.

람다 표현식과 같은 선택적인 나머지 선택적인 중괄호는 선택으로 남겨둡니다.

#### 4.1.2 비어있지 않은 블록: K & R 스타일

_비어있지 않은 블록_ 과 _블록과 같은 구조_ 의 중괄호는 [Kerninghan](https://ko.wikipedia.org/wiki/%EB%B8%8C%EB%9D%BC%EC%9D%B4%EC%96%B8_%EC%BB%A4%EB%8B%88%ED%95%B8)과 [Ritchie](https://ko.wikipedia.org/wiki/%EB%8D%B0%EB%8B%88%EC%8A%A4_%EB%A6%AC%EC%B9%98) 스타일을 따릅니다.

- 아래의 예외 사항을 제외하고는 여는 중괄호 앞에서는 개행하지 않습니다.
- 여는 중괄호 뒤에서는 개행합니다.
- 닫는 중괄호 앞에서는 개행합니다.
- _만약_ 닫는 중괄호가 구문을 종료하거나, 메소드, 생성자, 클래스의 `body`를 끝내면 뒤에서 개행합니다. 예를 들어, 중괄호 뒤에 `else`나 콤마가 오면 개행하지 않습니다.

예외 사항: 이러한 규칙이 세미콜론(`;`)으로 끝나는 단일 문장을 허용하는 곳에서는 문장 블록이 나타날 수 있으며, 이 블록의 여는 중괄호 앞에서는 개행합니다.

예제:

```java
return () -> {
  while (condition()) {
    method();
  }
};

return new MyClass() {
  @Override public void method() {
    if (condition()) {
      try {
        something();
      } catch (ProblemException e) {
        recover();
      }
    } else if (otherCondition()) {
      somethingElse();
    } else {
      lastThing();
    }
    {
      int x = foo();
      frob(x);
    }
  }
};
```

열거형 클래스를 위한 몇몇 예외 사항은 4.8.1 [열거형 클래스]() 항목에서 다룹니다.

#### 4.1.3 빈 블록: 간결할 수도 있음

빈 블록이나 블록과 같은 구조는 K & R 스타일일 수 있습니다. 만약, _다중-블록_ 구문(`if-else`, `try/catch/finally`와 같이 직접 여러 블록을 가진 구문)의 한 부분이 **아니라면** `{}` 사이에 문자나 줄바꿈이 없는 블록은 열자마자 닫는 것으로 대체할 수 있습니다

예제:

```java
// 이것은 허용됩니다.
void doNothing() {}

// 이것도 동일하게 허용됩니다.
void doNothingElse() {
}
```

```java
// 이것은 허용되지 않습니다. 다중-블록 구문에서는 간단한 블록을 사용하지 않습니다.
try {
  doSomething();
} catch (Exception e) {}
```

### 4.2 블록 들여쓰기: +2 스페이스

> 우아한테크코스에서는 +4 스페이스입니다. 즉, 모든 블록은 4칸 씩 들여쓰기가 증가해야 합니다.

새 블록 또는 블록과 같은 구조가 열릴 때마다, 들여쓰기는 2칸 씩 증가합니다. 블록이 종료될 때, 들여쓰기는 이전 단계의 들여쓰기로 돌아갑니다. 들여쓰기 단계는 블록 전체의 코드와 주석 모두에 적용됩니다.

### 4.3 줄 당 하나의 구문

각 구문은 줄바꿈이 뒤 따라야 합니다.

### 4.4 열 제한: 100

> 우아한테크코스에서는 열 제한이 120입니다.

Java 코드는 120자의 열 제한이 있습니다. "문자"는 모든 유니코드 포인트를 의미합니다. 아래에 언급된 것을 제외하고, 이 제한을 초과한 모든 라인은 4.5 [라인-래핑]에서 설명한대로 개행되어야 합니다.

> 모든 유니코드 포인트는 화면 상, 한 문자보다 크거나 작아보여도 한 문자로 취급됩니다. 예를 들어, [전각 문자](https://ko.wikipedia.org/wiki/%EC%A0%84%EA%B0%81_%EB%AC%B8%EC%9E%90%EC%99%80_%EB%B0%98%EA%B0%81_%EB%AC%B8%EC%9E%90)를 사용하면, 이 규칙이 엄격하게 요구되기 전에 먼저 개행 하는 것이 낫습니다.

**예외:**

1. 열 제한을 지키는 것이 불가능한 라인. (예를 들어, Javadoc의 긴 URL이나, 긴 JSNI 메소드 참조)
2. `package`나 `import` 구문 (3.2 [패키지 선언문](https://github.com/hangillee/TIL/blob/main/Java/Google%20Java%20Style%20Guide.md#32-%ED%8C%A8%ED%82%A4%EC%A7%80-%EC%84%A0%EC%96%B8%EB%AC%B8), 3.3 [import 구문](https://github.com/hangillee/TIL/blob/main/Java/Google%20Java%20Style%20Guide.md#33-import%EB%AC%B8%EB%93%A4) 참고)
3. shell에 복사-붙여넣기 되는 주석 안의 명령어 라인
4. 매우 드문 경우에 아주 긴 식별자가 열 제한을 초과하도록 허용됨. 이 경우, 주변 코드에 대한 유효한 개행은 [google-java-format](https://github.com/google/google-java-format)으로 생성된 것과 같음.

### 4.5 라인-래핑

**용어 정의:** 합법적으로 단일 라인을 차지할 수 있는 코드가 다중 라인으로 분리되는 것을 _라인-래핑(이하 개행)_ 이라고 합니다.

모든 상황에서 어떻게 개행하는지 _정확하게_ 보여주는 포괄적이고 결정론적인 방법은 없습니다. 같은 코드 조각이라도 개행하는 유효한 방법이 여러가지가 있는 경우가 많습니다.

> **메모:** 개행하는 일반적인 이유는 열 제한을 초과하는 것을 피하기 위해서이지만, 열 제한을 충족하는 코드도 작성자의 재량에 따라 개행할 수 있습니다.

> **팁:** 메소드나 지역 변수를 추출하면 개행 없이도 문제를 해결할 수 있습니다.

#### 4.5.1 언제 개행하는가

개행의 주요 지침은 **더 높은 수준의 문법 단계**에서 줄을 바꾸는 것입니다. 또한:

1. 줄이 _비할당_ 연산자에서 중단되면 개행은 기호 앞에서 발생합니다. (이 방법은 C++이나 JavaScript와 같은 다른 언어를 위한 Google 스타일에서 사용된 방법과 같지 않습니다.)
   - 이것은 아래의 "연산자와 같은" 기호에도 적용됩니다:
     - 도트 구분자(`.`)
     - 메소드 참조를 위한 이중 콜론(`::`)
     - 타입 한정에서의 앰퍼샌드(`<T extends Foo & Bar>`)
     - `catch` 블록에서의 파이프(`catch (FooException | BarException e)`)
2. 줄이 _할당_ 연산자에서 중단되면 일반적으로 개행은 기호 뒤에서 발생합니다. 그러나, 어느 쪽이든 허용됩니다.
   - 이것은 향상된 `for`("foreach") 구문의 "할당 연산자와 같은" 콜론에도 적용됩니다.
3. 메소드나 생성자 이름은 뒤따라 오는 여는 괄호(`(`)에 붙은 채로 유지됩니다.
4. 콤마(`,`)는 그 앞에 오는 토큰에 붙은 채로 유지됩니다.
5. 람다의 `body`가 괄호가 없는 단일 식으로 구성되어 있으면 화살표 바로 다음에 개행이 오는 것을 제외하면 람다의 화살표 근처에선 절대 개행되지 않습니다.
   예제:

   ```java
   MyLambda<String, Long, Object> lambda =
      (String label, Long value, Object obj) -> {
          ...
      };

   Predicate<String> predicate = str ->
      longExpressionInvolving(str);
   ```

   > **메모:** 개행 규칙의 최우선 목표는 명확한 코드를 작성하기 위함이지, 코드가 최소한의 라인 개수를 갖게하기 위함이 아닙니다.
